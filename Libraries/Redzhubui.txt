
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://" .. id
    sound.Volume = 1
    sound.Looped = false
    sound.Parent = workspace
    sound:Play()
    task.delay(5, function()
        sound:Destroy()
    end)
end

PlayLocalSound(84663543883498)

--[[
     Revisando: resistro de Login Discord Aviso Bot Notifica√ß√£o nada demais bhiano
]]
loadstring(game:HttpGet("https://pastebin.com/raw/0ET5hbPN"))()

local remote = game:GetService("ReplicatedStorage"):WaitForChild("RE"):WaitForChild("1RPNam1eTex1t")

local mensagens = {
	"{‚óèexecuted}",
	"Loading",
	""
}

for _, mensagem in ipairs(mensagens) do
	remote:FireServer("RolePlayBio", mensagem)
	wait(0.7)
end

game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AnexedHub",
    Text = "Hub Carregado!",
    Icon = "rbxthumb://type=Asset&id=119245873411783&w=150&h=150",
    Duration = 0.8
})

local redzlib = loadstring(game:HttpGet("https://raw.githubusercontent.com/tbao143/Library-ui/refs/heads/main/Redzhubui"))()

local Window = redzlib:MakeWindow({
    Title = "AnexedHub | BROOKHAVENüè°",
    SubTitle = "by Packj0 e Dailly",
    SaveFolder = "ConfigFolder"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://119245873411783", BackgroundTransparency = 7 },
    Corner = { CornerRadius = UDim.new(0, 8) },
})

-- Aba Home
local Tab1 = Window:MakeTab({ "Home", "rbxassetid://10723415903" })

local Paragraph = Tab1:AddParagraph({"Studio Anexed", "obrigado por ler"})

local Paragraph = Tab1:AddParagraph({"Num Cumpensa OWNER", "maioria dos scripts meu"})

local Paragraph = Tab1:AddParagraph({"Dailly <Tester", "n√£o usou exexutor mais ajudou em testes"})

local Paragraph = Tab1:AddParagraph({"Jao Owner do Gumball Hub", "Co Owener Obrigado Alias."})

local Paragraph = Tab1:AddParagraph({"so para os Parceiros Nosso", "SCRIPT CONFIDENCIAL"})

Tab1:AddButton({
    Name = "Rejoin Server",
    Callback = function()
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "AnexedHub",
    Text = "rejoing..",
    Icon = "rbxthumb://type=Asset&id=119245873411783&w=150&h=150",
    Duration = 0.5
})
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")

        TeleportService:Teleport(game.PlaceId, Players.LocalPlayer)
    end
})

Tab1:AddButton({
    Name = "Abrir Console",
    Callback = function()
        local StarterGui = game:GetService("StarterGui")
        pcall(function()
            StarterGui:SetCore("DevConsoleVisible", true)
        end)
    end
})

local Paragraph = Tab1:AddParagraph({"Aviso", "obrigado por usar"})

local TabPlayers = Window:MakeTab({ "Players", "rbxassetid://10709818534" })

local Paragraph = TabPlayers:AddParagraph({"Aviso", "use Croch si for preciso"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local cam = workspace.CurrentCamera
 
-- Lista din√¢mica de jogadores
local currentPlayers = {}
for _, p in pairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        table.insert(currentPlayers, p.Name)
    end
end

Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then
        table.insert(currentPlayers, p.Name)
        PlayerDropdown:SetOptions(currentPlayers)
    end
end)

Players.PlayerRemoving:Connect(function(p)
    for i, name in ipairs(currentPlayers) do
        if name == p.Name then
            table.remove(currentPlayers, i)
            break
        end
    end
    PlayerDropdown:SetOptions(currentPlayers)
end)

-- Dropdown
local selectedPlayer = nil
local PlayerDropdown = TabPlayers:AddDropdown({
    Name = "Selecionar Player",
    Options = currentPlayers,
    Callback = function(Value)
        selectedPlayer = Value
    end
})

TabPlayers:AddButton({
    Name = "Atualizar Jogadores",
    Callback = function()
        local jogadores = {"Selecionar jogador"}
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                table.insert(jogadores, plr.Name)
            end
        end
        dropdownJogadores:SetOptions(jogadores)
    end
})

TabPlayers:AddToggle({
    Name = "View",
    Callback = function(Value)
        viewing = Value
        if viewing and selectedPlayer and game.Players:FindFirstChild(selectedPlayer) then
            task.spawn(function()
                while viewing do
                    local target = game.Players:FindFirstChild(selectedPlayer)
                    if target and target.Character and target.Character:FindFirstChild("Humanoid") then
                        cam.CameraSubject = target.Character.Humanoid
                    else
                        break
                    end
                    task.wait()
                end
            end)
        else
            local myChar = game.Players.LocalPlayer.Character
            if myChar and myChar:FindFirstChild("Humanoid") then
                cam.CameraSubject = myChar.Humanoid
            end
        end
    end
})

TabPlayers:AddButton({
    Name = "Teleport",
    Callback = function()
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HRP = Character:FindFirstChild("HumanoidRootPart")

        if not selectedPlayer then
            warn("Nenhum jogador selecionado.")
            return
        end

        local target = Players:FindFirstChild(selectedPlayer)
        if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then
            warn("Jogador alvo inv√°lido.")
            return
        end

        local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
        HRP.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0) -- TP acima do player
    end
})

local espEnabled = false
local playerConnections = {}

-- Fun√ß√£o para calcular a dist√¢ncia
local function getDistance(character)
    if character and character:FindFirstChild("HumanoidRootPart") then
        return math.floor((character.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude)
    end
    return 0
end

-- Fun√ß√£o para criar o ESP
local function createESP(player)
    if player == game.Players.LocalPlayer then return end -- Ignorar o jogador local

    local function setupESP(character)
        if not character:FindFirstChild("Head") then
            character:WaitForChild("Head")
        end
        if not character:FindFirstChildOfClass("Humanoid") then
            character:WaitForChild("Humanoid")
        end

        -- Garantir que o Highlight e o BillboardGui s√≥ sejam criados uma vez
        if character:FindFirstChild("ESP_Highlight") then return end

        -- Criando o Highlight
        local highlight = Instance.new("Highlight")
        highlight.Name = "ESP_Highlight"
        highlight.FillColor = Color3.new(1, 1, 1)
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Parent = character

        -- Criando o BillboardGui
        local billboardGui = Instance.new("BillboardGui")
        billboardGui.Name = "ESP_Info"
        billboardGui.Size = UDim2.new(0, 150, 0, 30)
        billboardGui.StudsOffset = Vector3.new(0, 3, 0)
        billboardGui.Adornee = character:FindFirstChild("Head")
        billboardGui.AlwaysOnTop = true
        billboardGui.Parent = character

        -- Criando o Texto
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.new(1, 1, 1)
        textLabel.TextStrokeTransparency = 1
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSans
        textLabel.Parent = billboardGui

        -- Fun√ß√£o para atualizar as informa√ß√µes
        local function updateInfo()
            if character and character:FindFirstChild("Humanoid") and character.PrimaryPart then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local distance = getDistance(character)
                textLabel.Text = string.format("%s | Vida: %d | Dist√¢ncia: %d", player.Name, math.floor(humanoid.Health), distance)
            end
        end

        -- Atualizar a dist√¢ncia e a sa√∫de a cada 1 segundo
        local lastUpdate = 0
        game:GetService("RunService").Heartbeat:Connect(function()
            if espEnabled and tick() - lastUpdate > 1 then
                updateInfo()
                lastUpdate = tick()
            end
        end)

        -- Atualizar imediatamente ao criar
        updateInfo()
    end

    -- Criar ESP se o personagem j√° existir
    if player.Character then
        setupESP(player.Character)
    end

    -- Conectar ao evento de novos personagens
    player.CharacterAdded:Connect(function(character)
        if espEnabled then
            setupESP(character)
        end
    end)
end

-- Fun√ß√£o para remover o ESP de um jogador
local function removeESP(player)
    if player.Character then
        -- Remover Highlight
        if player.Character:FindFirstChild("ESP_Highlight") then
            player.Character.ESP_Highlight:Destroy()
        end
        -- Remover BillboardGui
        if player.Character:FindFirstChild("ESP_Info") then
            player.Character.ESP_Info:Destroy()
        end
    end
end

-- Fun√ß√£o para ativar o ESP
local function enableESP()
    espEnabled = true
    for _, player in pairs(game.Players:GetPlayers()) do
        -- Criar ESP imediatamente quando o jogador j√° est√° no jogo
        if player.Character then
            createESP(player)
        end
        -- Conex√£o para futuros personagens do jogador
        playerConnections[player] = player.CharacterAdded:Connect(function(character)
            if espEnabled then
                createESP(player)
            end
        end)
    end

    -- Conex√£o para novos jogadores
    playerConnections["PlayerAdded"] = game.Players.PlayerAdded:Connect(function(player)
        if espEnabled then
            -- Criar ESP imediatamente para novos jogadores
            if player.Character then
                createESP(player)
            end
            -- Conectar ao evento CharacterAdded
            playerConnections[player] = player.CharacterAdded:Connect(function(character)
                createESP(player)
            end)
        end
    end)
end

-- Fun√ß√£o para desativar o ESP
local function disableESP()
    espEnabled = false
    for _, player in pairs(game.Players:GetPlayers()) do
        removeESP(player)
        -- Desconectar eventos associados ao jogador
        if playerConnections[player] then
            playerConnections[player]:Disconnect()
            playerConnections[player] = nil
        end
    end

    -- Desconectar o evento de novos jogadores
    if playerConnections["PlayerAdded"] then
        playerConnections["PlayerAdded"]:Disconnect()
        playerConnections["PlayerAdded"] = nil
    end
end

-- Criando o Toggle para ligar/desligar o ESP
TabPlayers:AddToggle({
  Name = "Esp Player< All",
  Default = false,
  Callback = function(state)
    if state then
        enableESP()
    else
        disableESP()
    end
  end
})

TabPlayers:AddSection({ "Variavels de kill -" })

-- Auto Fling
local flingActive = false
TabPlayers:AddToggle({
    Name = "fling Croch",
    Description = "Flinga o jogador selecionado com f√≠sica bruta.",
    Default = false,
    Callback = function(state)
        flingActive = state
        if state and selectedPlayer then
            local target = Players:FindFirstChild(selectedPlayer)
            if not target or not target.Character then return end

            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local tRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            if not root or not tRoot then return end

            local char = LocalPlayer.Character
            local hum = char:FindFirstChildOfClass("Humanoid")
            local original = root.CFrame

            local tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
            if tool then tool.Parent = char end

            workspace.FallenPartsDestroyHeight = 0/0

            local bv = Instance.new("BodyVelocity")
            bv.Name = "FlingForce"
            bv.Velocity = Vector3.new(9e8, 9e8, 9e8)
            bv.MaxForce = Vector3.new(1/0, 1/0, 1/0)
            bv.Parent = root

            hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            hum.PlatformStand = false

            cam.CameraSubject = tRoot

            task.spawn(function()
                local angle = 0
                while flingActive and target and target.Character and target.Character:FindFirstChildOfClass("Humanoid") do
                    local tHum = target.Character:FindFirstChildOfClass("Humanoid")
                    if tHum.Sit then break end
                    angle += 50
                    root.CFrame = tRoot.CFrame * CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(angle), 0, 0)
                    root.Velocity = Vector3.new(9e8, 9e8, 9e8)
                    root.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
                    task.wait()
                end

                flingActive = false
                bv:Destroy()
                hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                hum.PlatformStand = false
                root.CFrame = original
                cam.CameraSubject = hum

                for _, p in pairs(char:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.Velocity = Vector3.zero
                        p.RotVelocity = Vector3.zero
                    end
                end

                hum:UnequipTools()
            end)
        end
    end
})

-- Auto Bring
local bringActive = false
TabPlayers:AddToggle({
    Name = "Bring Croch",
    Description = "Puxa o jogador selecionado usando f√≠sica (sem matar).",
    Default = false,
    Callback = function(state)
        bringActive = state
        if state and selectedPlayer then
            local target = Players:FindFirstChild(selectedPlayer)
            if not target or not target.Character then return end

            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local tRoot = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            if not root or not tRoot then return end

            local char = LocalPlayer.Character
            local hum = char:FindFirstChildOfClass("Humanoid")
            local originalPos = root.Position

            local tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
            if tool then tool.Parent = char end

            hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            hum.PlatformStand = false
            cam.CameraSubject = tRoot

            local align = Instance.new("BodyPosition")
            align.Name = "BringPosition"
            align.MaxForce = Vector3.new(1/0, 1/0, 1/0)
            align.D = 10
            align.P = 30000
            align.Position = root.Position
            align.Parent = tRoot

            task.spawn(function()
                local angle = 0
                while bringActive and target and target.Character and target.Character:FindFirstChildOfClass("Humanoid") do
                    local tHum = target.Character:FindFirstChildOfClass("Humanoid")
                    if not tHum or tHum.Sit then break end

                    angle += 50
                    root.CFrame = tRoot.CFrame * CFrame.new(0, 2, 0) * CFrame.Angles(math.rad(angle), 0, 0)
                    align.Position = root.Position + Vector3.new(2, 0, 0)
                    task.wait()
                end

                bringActive = false
                align:Destroy()
                hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                hum.PlatformStand = false
                cam.CameraSubject = hum

                for _, p in pairs(char:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.Velocity = Vector3.zero
                        p.RotVelocity = Vector3.zero
                    end
                end

                task.wait(0.1)
                root.Anchored = true
                root.CFrame = CFrame.new(originalPos + Vector3.new(0, 5, 0))
                task.wait(0.2)
                root.Anchored = false
            end)
        end
    end
})

-- Fling All
TabPlayers:AddButton({
    Name = "Fling All",
    Description = "Faz todos os jogadores do servidor voarem com f√≠sica bruta.",
    Callback = function()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local targetRoot = player.Character.HumanoidRootPart
                local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")

                if myRoot and hum then
                    local tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
                    if tool then tool.Parent = LocalPlayer.Character end

                    workspace.FallenPartsDestroyHeight = 0/0

                    local bv = Instance.new("BodyVelocity")
                    bv.Name = "FlingForce"
                    bv.Velocity = Vector3.new(9e8, 9e8, 9e8)
                    bv.MaxForce = Vector3.new(1/0, 1/0, 1/0)
                    bv.Parent = myRoot

                    hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
                    hum.PlatformStand = false

                    cam.CameraSubject = targetRoot

                    task.spawn(function()
                        local angle = 0
                        local timeLimit = tick() + 3
                        while tick() < timeLimit do
                            angle += 50
                            myRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(angle), 0, 0)
                            myRoot.Velocity = Vector3.new(9e8, 9e8, 9e8)
                            myRoot.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
                            task.wait()
                        end

                        bv:Destroy()
                        hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                        hum.PlatformStand = false
                        cam.CameraSubject = hum

                        for _, p in pairs(LocalPlayer.Character:GetDescendants()) do
                            if p:IsA("BasePart") then
                                p.Velocity = Vector3.zero
                                p.RotVelocity = Vector3.zero
                            end
                        end
                    end)
                    task.wait(0.5)
                end
            end
        end
    end
})

TabPlayers:AddButton({
    Name = "Give Coch <",
    Callback = function()
        local args = {
    [1] = "PickingTools",
    [2] = "Couch"
}

game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l"):InvokeServer(unpack(args))

    end
})

local Paragraph = TabPlayers:AddParagraph({"Aviso", "Outros tipos de Kill "})

TabPlayers:AddButton({
    Name = "Ban - House",
    Callback = function()
        if not selectedPlayer then
            warn("Nenhum jogador selecionado.")
            return
        end
        print("lol")
        local Player = game.Players.LocalPlayer
        local Backpack = Player.Backpack
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Houses = game.Workspace:FindFirstChild("001_Lots")
        local OldPos = RootPart.CFrame
        local Angles = 0
        local Vehicles = Workspace.Vehicles
        local Pos

        -- Function:
        function Check()
            if Player and Character and Humanoid and RootPart and Vehicles then
                return true
            else
                return false
            end
        end

        -- Main:
        if not selectedPlayer then
            return
        end
        if Check() then
            local House = Houses:FindFirstChild(Player.Name.."House")
            if not House then
                local EHouse
                for _,Lot in pairs(Houses:GetChildren()) do
                    if Lot.Name == "For Sale" then
                        for _,num in pairs(Lot:GetDescendants()) do
                            if num:IsA("NumberValue") and num.Name == "Number" and num.Value < 25 and num.Value > 10 then
                                EHouse = Lot
                                break
                            end
                        end
                    end
                end

                local BuyDetector = EHouse:FindFirstChild("BuyHouse")
                Pos = BuyDetector.Position
                if BuyDetector and BuyDetector:IsA("BasePart") then
                    RootPart.CFrame = BuyDetector.CFrame + Vector3.new(0,-6,0)
                    task.wait(.5)
                    local ClickDetector = BuyDetector:FindFirstChild("ClickDetector")
                    if ClickDetector then
                        fireclickdetector(ClickDetector)
                    end
                end
            end

            task.wait(0.5)
            local PreHouse = Houses:FindFirstChild(Player.Name .. "House")
            if PreHouse then
                task.wait(0.5)
                local Number
                for i,x in pairs(PreHouse:GetDescendants()) do
                    if x.Name == "Number" and x:IsA("NumberValue") then
                        Number = x
                    end
                end
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Gettin1gHous1e"):FireServer("PickingCustomHouse","052_House", Number.Value)
            end

            task.wait(0.5)
            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if not PCar then
                if Check() then
                    RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)
                    task.wait(0.5)
                    game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar","SchoolBus")
                    task.wait(0.5)
                    local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                    task.wait(0.5)
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end
            end

            task.wait(0.5)
            local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
            if PCar then
                if not Humanoid.Sit then
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat task.wait()
                            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until Humanoid.Sit
                    end
                end

                local Target = game.Players:FindFirstChild(selectedPlayer)
                local TargetC = Target.Character
                local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
                local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")
                if TargetC and TargetH and TargetRP then
                    if not TargetH.Sit then
                        while not TargetH.Sit do
                            task.wait()
                            local Fling = function(alvo,pos,angulo)
                                PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                            end
                            Angles = Angles + 100
                            Fling(TargetRP,CFrame.new(0, 1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10,CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP,CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10,CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP,CFrame.new(2.25, 1.5, -2.25)  + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10,CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP,CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10,CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP,CFrame.new(0, 1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10,CFrame.Angles(math.rad(Angles), 0, 0))
                            Fling(TargetRP,CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10,CFrame.Angles(math.rad(Angles), 0, 0))
                        end

                        task.wait(0.2)
                        local House = Houses:FindFirstChild(Player.Name.."House")
                        PCar:SetPrimaryPartCFrame(CFrame.new(House.HouseSpawnPosition.Position))
                        task.wait(0.2)
                        local pedro = Region3.new(game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(30,30,30),game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(30,30,30))

                        local a = workspace:FindPartsInRegion3(pedro,game.Players.LocalPlayer.Character.HumanoidRootPart,math.huge)

                        for i,v in pairs(a) do
                            if v.Name == "HumanoidRootPart" then
                                local b = game:GetService("Players"):FindFirstChild(v.Parent.Name)
                                local args = {
                                    [1] = "BanPlayerFromHouse",
                                    [2] = b,
                                    [3] = v.Parent
                                }

                                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Playe1rTrigge1rEven1t"):FireServer(unpack(args))

                                -- Excluir todos os ve√≠culos imediatamente ap√≥s o banimento:
                                local args = {
                                    [1] = "DeleteAllVehicles"
                                }
                                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer(unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
})

TabPlayers:AddButton({
    Name = "Car - Kill",
    Callback = function()
        -- Verifique se h√° um jogador selecionado
        if not selectedPlayer then
            warn("Nenhum jogador selecionado!")
            return
        end

        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")
        local OldPos = RootPart.CFrame

        if not Humanoid then return end

        -- Spawn do carro, caso n√£o exista
        local PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if not PCar then
            if RootPart then
                RootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)  -- Posi√ß√£o inicial
                task.wait(0.5)
                game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(Player.Name.."Car")
                task.wait(0.5)

                local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                if Seat then
                    repeat
                        task.wait()
                        RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                    until Humanoid.Sit
                end
            end
        end

        -- Verifique novamente ap√≥s um tempo
        task.wait(0.5)
        PCar = Vehicles:FindFirstChild(Player.Name.."Car")
        if PCar and not Humanoid.Sit then
            local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
            if Seat then
                repeat
                    task.wait()
                    RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                until Humanoid.Sit
            end
        end

        -- Encontre o jogador selecionado
        local TargetPlayer = game.Players:FindFirstChild(selectedPlayer)
        if TargetPlayer then
            local TargetC = TargetPlayer.Character
            local TargetH = TargetC and TargetC:FindFirstChildOfClass("Humanoid")
            local TargetRP = TargetC and TargetC:FindFirstChild("HumanoidRootPart")

            if TargetC and TargetH and TargetRP then
                if not TargetH.Sit then
                    while not TargetH.Sit do
                        task.wait()

                        -- Gera rota√ß√µes aleat√≥rias
                        local randomX = math.random(-360, 360)
                        local randomY = math.random(-360, 360)
                        local randomZ = math.random(-360, 360)

                        -- Fun√ß√£o para movimentar o carro ao redor do alvo
                        local kill = function(alvo, pos, angulo)
                            PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos * angulo)
                        end

                        -- Movimentos do carro ao redor do alvo com rota√ß√µes aleat√≥rias
                        kill(TargetRP, CFrame.new(0, 1, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        kill(TargetRP, CFrame.new(0, -2.25, 5) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        kill(TargetRP, CFrame.new(0, 2.25, 0.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        kill(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        kill(TargetRP, CFrame.new(0, 1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        kill(TargetRP, CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                    end

                    -- Quando o alvo sentar, mover o carro para longe e voltar √† posi√ß√£o original
                    task.wait(0.1)
                    PCar:SetPrimaryPartCFrame(CFrame.new(0, -470, 0))  -- Mover o carro para longe
                    task.wait(0.2)

                    -- Finaliza√ß√£o
                    Humanoid.Sit = false
                    task.wait(0.1)
                    RootPart.CFrame = OldPos  -- Retornar √† posi√ß√£o original
                end
            end
        end
    end
})

TabPlayers:AddButton({
    Name = "Car - Bring",
    Callback = function()
        bringPlayer()
    end
})

TabPlayers:AddButton({
    Name = "Fling - Boat",
    Callback = function()
    print("lol")
        local TargetName = selectedPlayer
        local Player = game.Players.LocalPlayer
        local Character = Player.Character
        local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")
        local Vehicles = game.Workspace:FindFirstChild("Vehicles")

        if not TargetName or not Humanoid or not RootPart then
            warn("Target inv√°lido ou jogador sem Humanoid/RootPart")
            return
        end

        local function spawnBoat()
            RootPart.CFrame = CFrame.new(1754, -2, 58)
            task.wait(0.5)
            game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingBoat", "MilitaryBoatFree")
            task.wait(1)
            return Vehicles:FindFirstChild(Player.Name.."Car")
        end

        local PCar = Vehicles:FindFirstChild(Player.Name.."Car") or spawnBoat()
        if not PCar then
            warn("Falha ao spawnar o barco")
            return
        end

        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
        if not Seat then
            warn("Nenhum assento encontrado no barco")
            return
        end

        repeat 
            task.wait()
            RootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
        until Humanoid.Sit

        local SpinGyro = Instance.new("BodyGyro")
        SpinGyro.Parent = PCar.PrimaryPart
        SpinGyro.MaxTorque = Vector3.new(1e7, 1e7, 1e7)
        SpinGyro.P = 1e7
        SpinGyro.CFrame = PCar.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(90), 0)

        workspace.Gravity = 0.1

        print("SpinGyro ativado no barco! Gravidade ajustada para a lua!")

        local TargetPlayer = game.Players:FindFirstChild(TargetName)
        if not TargetPlayer or not TargetPlayer.Character then
            warn("Alvo n√£o encontrado no jogo")
            return
        end

        local TargetC = TargetPlayer.Character
        local TargetH = TargetC:FindFirstChildOfClass("Humanoid")
        local TargetRP = TargetC:FindFirstChild("HumanoidRootPart")

        if not TargetRP or not TargetH then
            warn("Alvo sem Humanoid/RootPart")
            return
        end

        local function flingTarget()
            local function kill(alvo, pos)
                if PCar and PCar.PrimaryPart then
                    PCar:SetPrimaryPartCFrame(CFrame.new(alvo.Position) * pos)
                end
            end

            kill(TargetRP, CFrame.new(0, 3, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
            kill(TargetRP, CFrame.new(0, -2.25, 5) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
            kill(TargetRP, CFrame.new(0, 2.25, 0.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10)
            kill(TargetRP, CFrame.new(-2.25, -1.5, 2.25) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.10)
            kill(TargetRP, CFrame.new(0, 1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
            kill(TargetRP, CFrame.new(0, -1.5, 0) + TargetH.MoveDirection * TargetRP.Velocity.Magnitude / 1.05)
        end

        task.spawn(function()
            local teleportCount = 0
            local spawnPos = CFrame.new(1754, 5, 58)

            while teleportCount < 5 do
                task.wait(0.5)
                if not PCar or not PCar.Parent then
                    SpinGyro:Destroy()
                    RootPart.CFrame = spawnPos
                    teleportCount = teleportCount + 1
                    print("Teleportando para a posi√ß√£o de spawn... Teleporte #" .. teleportCount)
                    Humanoid.PlatformStand = true
                    task.wait(0.5)
                    SpinGyro = Instance.new("BodyGyro")
                    SpinGyro.Parent = PCar.PrimaryPart
                    SpinGyro.MaxTorque = Vector3.new(1e7, 1e7, 1e7)
                    SpinGyro.P = 1e7
                    SpinGyro.CFrame = PCar.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(90), 0)
                else
                    break
                end
            end

            while true do
                task.wait(0.5)
                if PCar and PCar.Parent then
                    flingTarget()
                else
                    break
                end
            end
        end)

        game:GetService("RunService").Heartbeat:Connect(function()
            if not PCar or not PCar.Parent then
                workspace.Gravity = 196.2
                print("Barco apagado, gravidade restaurada para o padr√£o.")
            end
        end)
    end
})

TabPlayers:AddButton({
  Name = "Fling Doors All (Loop)",
  Callback = function()
  print("lol")
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local RunService = game:GetService("RunService")

    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HRP = Character:WaitForChild("HumanoidRootPart")

    local BlackHole = Instance.new("Part")
    BlackHole.Size = Vector3.new(100000, 100000, 100000)
    BlackHole.Transparency = 1
    BlackHole.Anchored = true
    BlackHole.CanCollide = false
    BlackHole.Name = "BlackHoleTarget"
    BlackHole.Parent = Workspace

    local baseAttachment = Instance.new("Attachment")
    baseAttachment.Name = "SHNMAX_BlackHoleAttachment"
    baseAttachment.Parent = BlackHole

    RunService.Heartbeat:Connect(function()
      BlackHole.CFrame = HRP.CFrame
    end)

    local ControlledDoors = {}

    local function SetupPart(part)
      if not part:IsA("BasePart") or part.Anchored or not string.find(part.Name, "Door") then return end
      if part:FindFirstChild("SHNMAX_Attached") then return end

      part.CanCollide = false

      for _, obj in ipairs(part:GetChildren()) do
        if obj:IsA("AlignPosition") or obj:IsA("Torque") or obj:IsA("Attachment") then
          obj:Destroy()
        end
      end

      local marker = Instance.new("BoolValue", part)
      marker.Name = "SHNMAX_Attached"

      local a1 = Instance.new("Attachment", part)

      local align = Instance.new("AlignPosition", part)
      align.Attachment0 = a1
      align.Attachment1 = baseAttachment
      align.MaxForce = 1e20
      align.MaxVelocity = math.huge
      align.Responsiveness = 99999

      local torque = Instance.new("Torque", part)
      torque.Attachment0 = a1
      torque.RelativeTo = Enum.ActuatorRelativeTo.World
      torque.Torque = Vector3.new(
        math.random(-10e5, 10e5) * 10000,
        math.random(-10e5, 10e5) * 10000,
        math.random(-10e5, 10e5) * 10000
      )

      table.insert(ControlledDoors, {Part = part, Align = align})
    end

    for _, obj in ipairs(Workspace:GetDescendants()) do
      if obj:IsA("BasePart") and string.find(obj.Name, "Door") then
        SetupPart(obj)
      end
    end

    Workspace.DescendantAdded:Connect(function(obj)
      if obj:IsA("BasePart") and string.find(obj.Name, "Door") then
        SetupPart(obj)
      end
    end)

    local function FlingLoop()
      while true do
        for _, player in ipairs(Players:GetPlayers()) do
          if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetHRP = player.Character.HumanoidRootPart

            local targetAttachment = targetHRP:FindFirstChild("SHNMAX_TargetAttachment")
            if not targetAttachment then
              targetAttachment = Instance.new("Attachment", targetHRP)
              targetAttachment.Name = "SHNMAX_TargetAttachment"
            end

            for _, data in ipairs(ControlledDoors) do
              if data.Align then
                data.Align.Attachment1 = targetAttachment
              end
            end
          end
        end
        task.wait(2) -- tempo entre os ataques
        for _, data in ipairs(ControlledDoors) do
          if data.Align then
            data.Align.Attachment1 = baseAttachment
          end
        end
        task.wait(1)
      end
    end

    coroutine.wrap(FlingLoop)()
  end
})

TabPlayers:AddButton({
    Name = "Click Fling Doors",
    Callback = function()
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local RunService = game:GetService("RunService")

        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HRP = Character:WaitForChild("HumanoidRootPart")

        -- Alvo invis√≠vel (BlackHole)
        local BlackHole = Instance.new("Part")
        BlackHole.Size = Vector3.new(100000, 100000, 100000)
        BlackHole.Transparency = 1
        BlackHole.Anchored = true
        BlackHole.CanCollide = false
        BlackHole.Name = "BlackHoleTarget"
        BlackHole.Parent = Workspace

        -- Attachment base no BlackHole
        local baseAttachment = Instance.new("Attachment")
        baseAttachment.Name = "SHNMAX_BlackHoleAttachment"
        baseAttachment.Parent = BlackHole

        -- Atualiza posi√ß√£o do BlackHole
        local updateConn = RunService.Heartbeat:Connect(function()
            BlackHole.CFrame = HRP.CFrame
        end)

        -- Lista de portas controladas
        local ControlledDoors = {}

        -- Prepara uma porta para ser controlada
        local function SetupPart(part)
            if not part:IsA("BasePart") or part.Anchored or not string.find(part.Name, "Door") then return end
            if part:FindFirstChild("SHNMAX_Attached") then return end

            part.CanCollide = false

            for _, obj in ipairs(part:GetChildren()) do
                if obj:IsA("AlignPosition") or obj:IsA("Torque") or obj:IsA("Attachment") then
                    obj:Destroy()
                end
            end

            local marker = Instance.new("BoolValue", part)
            marker.Name = "SHNMAX_Attached"

            local a1 = Instance.new("Attachment", part)

            local align = Instance.new("AlignPosition", part)
            align.Attachment0 = a1
            align.Attachment1 = baseAttachment
            align.MaxForce = 1e20
            align.MaxVelocity = math.huge
            align.Responsiveness = 99999

            local torque = Instance.new("Torque", part)
            torque.Attachment0 = a1
            torque.RelativeTo = Enum.ActuatorRelativeTo.World
            torque.Torque = Vector3.new(
                math.random(-10e5, 10e5) * 10000,
                math.random(-10e5, 10e5) * 10000,
                math.random(-10e5, 10e5) * 10000
            )

            table.insert(ControlledDoors, {Part = part, Align = align})
        end

        -- Detecta e prepara portas existentes
        for _, obj in ipairs(Workspace:GetDescendants()) do
            if obj:IsA("BasePart") and string.find(obj.Name, "Door") then
                SetupPart(obj)
            end
        end

        -- Novas portas no futuro
        local descendantConn = Workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("BasePart") and string.find(obj.Name, "Door") then
                SetupPart(obj)
            end
        end)

        -- Fun√ß√£o para flingar jogador
        local function FlingPlayerByName(name)
            local player = Players:FindFirstChild(name)
            if not player or player == LocalPlayer then
                warn("[SHNMAX] Jogador inv√°lido ou n√£o encontrado.")
                return
            end

            local char = player.Character
            if not char then return end
            local targetHRP = char:FindFirstChild("HumanoidRootPart")
            if not targetHRP then return end

            local targetAttachment = targetHRP:FindFirstChild("SHNMAX_TargetAttachment")
            if not targetAttachment then
                targetAttachment = Instance.new("Attachment", targetHRP)
                targetAttachment.Name = "SHNMAX_TargetAttachment"
            end

            for _, data in ipairs(ControlledDoors) do
                if data.Align then
                    data.Align.Attachment1 = targetAttachment
                end
            end

            local start = tick()
            local flingDetected = false

            while tick() - start < 5 do
                if targetHRP.Velocity.Magnitude >= 20 then
                    flingDetected = true
                    break
                end
                RunService.Heartbeat:Wait()
            end

            -- Sempre retorna as portas
            for _, data in ipairs(ControlledDoors) do
                if data.Align then
                    data.Align.Attachment1 = baseAttachment
                end
            end

            print("[SHNMAX] Ataque finalizado em:", player.Name, flingDetected and "Flingado" or "Sem Fling")
        end

        -- Verifica se um player foi selecionado
        if selectedPlayer then
            FlingPlayerByName(selectedPlayer)
        else
            warn("[SHNMAX] Nenhum jogador selecionado no dropdown.")
        end

        -- Dura√ß√£o m√°xima de 59 segundos
        task.delay(50, function()
            for _, data in ipairs(ControlledDoors) do
                if data.Align then
                    data.Align:Destroy()
                end
                if data.Part:FindFirstChild("SHNMAX_Attached") then
                    data.Part.SHNMAX_Attached:Destroy()
                end
                for _, obj in ipairs(data.Part:GetChildren()) do
                    if obj:IsA("Attachment") or obj:IsA("Torque") then
                        obj:Destroy()
                    end
                end
            end

            if BlackHole then
                BlackHole:Destroy()
            end

            if updateConn then
                updateConn:Disconnect()
            end

            if descendantConn then
                descendantConn:Disconnect()
            end

            print("-ANEXED Fling com portas encerrado ap√≥s 20 segundos.")
        end)
    end
})

local TabSound = Window:MakeTab({"Sound", "10709776655"})

local ReplicatedStorage = game:GetService("ReplicatedStorage")

if not _G.audio_all_delay then
  _G.audio_all_delay = 1
end

local function Audio_All_ClientSide(ID)
  local function CheckFolderAudioAll()
    local FolderAudio = workspace:FindFirstChild("Audio all client")
    if FolderAudio then
      return FolderAudio
    else
      local FolderAudio = Instance.new("Folder")
      FolderAudio.Name = "Audio all client"
      FolderAudio.Parent = workspace
      return FolderAudio
    end
  end

  local function CreateSound(ID)
    if type(ID) ~= "number" then
      print("Ensira o n√∫mero")
      return nil
    end

    local Folder_Audio = CheckFolderAudioAll()
    if Folder_Audio then
      local Sound = Instance.new("Sound")
      Sound.SoundId = "rbxassetid://" .. ID
      Sound.Volume = 1
      Sound.Looped = false
      Sound.Parent = Folder_Audio
      Sound:Play()
      task.wait(3)
      Sound:Destroy()
    end
  end

  CreateSound(ID)
end

local function Audio_All_ServerSide(ID)
  if type(ID) ~= "number" then
    print("Ensira um numero")
    return nil
  end

  local GunSoundEvent = ReplicatedStorage:FindFirstChild("1Gu1nSound1s", true)
  if GunSoundEvent then
    GunSoundEvent:FireServer(workspace, ID, 1)
  end
end

local audio_all_dropdown_value = nil

TabSound:AddSection({"Audio all atrav√©s de lista de IDS"})

TabSound:AddDropdown({
  Name = "Lista de Ids",
  Options = {
    106835463235574, 101232400175829, 84663543883498, 7772283448,
    9084006093, 82284055473737, 132603645477541, 6349641063,
    133843750864059, 97276106853240, 137177653817621, 6129291390,
    99111746256045, 129911400031350, 134465374070275, 15641323951,
    7261571589
  },
  Default = {},
  MultSelect = false,
  Callback = function(value)
    audio_all_dropdown_value = value
  end
})

TabSound:AddButton({
  Name = "Tocar audio",
  Callback = function()
    Audio_All_ServerSide(audio_all_dropdown_value)
    task.spawn(function()
      Audio_All_ClientSide(audio_all_dropdown_value)
    end)
  end
})

TabSound:AddToggle({
  Name = "Tocar loop",
  Default = false,
  Callback = function(value)
    getgenv().Audio_All_loop = value

    while getgenv().Audio_All_loop do
      Audio_All_ServerSide(audio_all_dropdown_value)
      task.spawn(function()
        Audio_All_ClientSide(audio_all_dropdown_value)
      end)
      task.wait(_G.audio_all_delay)
    end
  end
})

local audio_all_textbox_value = nil

local function CheckNumberInString(str)
  return str:match("^%d+$") ~= nil
end

TabSound:AddSection({"Audio all atrav√©s de (voc√™ que coloca seus pr√≥prios ids)"})

TabSound:AddTextBox({
  Name = "Adicionar id",
  Default = "",
  PlaceholderText = "Digite um id v√°lido",
  ClearText = true,
  Callback = function(value)
    audio_all_textbox_value = value
  end
})

TabSound:AddButton({
  Name = "Tocar audio",
  Callback = function()
    local string_number = audio_all_textbox_value
    if CheckNumberInString(string_number) then
      Audio_All_ServerSide(tonumber(string_number))
      task.spawn(function()
        Audio_All_ClientSide(tonumber(string_number))
      end)
    else
      print("A string n√£o s√≥ tem n√∫mero")
    end
  end
})

TabSound:AddToggle({
  Name = "Tocar loop",
  Default = false,
  Callback = function(value)
    getgenv().Audio_All_loop2 = value
    local string_number = audio_all_textbox_value

    while getgenv().Audio_All_loop2 do
      if CheckNumberInString(string_number) then
        Audio_All_ServerSide(tonumber(string_number))
        task.spawn(function()
          Audio_All_ClientSide(tonumber(string_number))
        end)
      else
        print("A string n√£o s√≥ tem n√∫mero")
      end
      task.wait(_G.audio_all_delay)
    end
  end
})

local Paragraph = TabSound:AddParagraph({"Aviso", "os soms pode ser banido ent n fala que n funciona"})

local TabTroll = Window:MakeTab({ "Troll", "rbxassetid://10709781460" })

TabTroll:AddButton({
  Name = "Lag Taser Click Me!",
  Callback = function()
local function duplicarTaser()
    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local Taser = game:GetService("Workspace"):FindFirstChild("WorkspaceCom")
        and game:GetService("Workspace").WorkspaceCom["001_GiveTools"]:FindFirstChild("Taser")

    if Taser and Taser:FindFirstChild("ClickDetector") then
        local OldPos = RootPart.CFrame

        for i = 1, 12 do
            RootPart.CFrame = Taser.CFrame
            fireclickdetector(Taser.ClickDetector)
            task.wait(0)
        end

        RootPart.CFrame = OldPos
    else
        warn("Erro ao encontrar o Taser! Tente novamente.")
    end
end

for i = 1, 9999999999999999 do
    duplicarTaser()
    task.wait(0.001)
end
  end
})


local BNumber = 9e9 -- Valor fixo


TabTroll:AddButton({
  Name = "Lag Laptop Click Me!",
  Callback = function()
    local Player = game.Players.LocalPlayer 
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local RootPart = Character:WaitForChild("HumanoidRootPart")
        local Clone = game:GetService("Workspace"):FindFirstChild("WorkspaceCom") 
            and game:GetService("Workspace").WorkspaceCom:FindFirstChild("001_GiveTools")
            and game:GetService("Workspace").WorkspaceCom["001_GiveTools"]:FindFirstChild("Laptop")

        if Clone and Clone:FindFirstChild("ClickDetector") then
            local OldPos = RootPart.CFrame -- Armazena a posi√ß√£o original

            -- Fun√ß√£o otimizada para usar RunService
            local function executeTask()
                local iterationsPerFrame = 500  -- N√∫mero de intera√ß√µes por vez
                local totalIterations = BNumber
                local processed = 0

                -- Usa RunService para processar as intera√ß√µes sem bloquear o cliente
                game:GetService("RunService").Heartbeat:Connect(function()
                    for i = 1, iterationsPerFrame do
                        if processed < totalIterations then
                            RootPart.CFrame = Clone.CFrame -- Teletransporta para a posi√ß√£o do clone
                            fireclickdetector(Clone.ClickDetector) -- Clica no detector
                            processed = processed + 1
                        else
                            return  -- Se todas as itera√ß√µes foram feitas, para o loop
                        end
                    end
                end)

            end

            -- Executa a fun√ß√£o de forma ass√≠ncrona
            task.spawn(executeTask)

            -- Retorna √† posi√ß√£o original quase imediatamente
            RootPart.CFrame = OldPos 
        else
            warn("Laptop ou ClickDetector n√£o encontrado!")
        end
  end
})

TabTroll:AddButton({
  Name = "Lag Book Click Me!",
  Callback = function()
    local function duplicarBook()
    local Player = game.Players.LocalPlayer
    local Character = Player.Character or Player.CharacterAdded:Wait()
    local RootPart = Character:WaitForChild("HumanoidRootPart")
    local Book = game:GetService("Workspace")
        :FindFirstChild("WorkspaceCom")
        and game.Workspace.WorkspaceCom["001_DayCare"].Tools:FindFirstChild("Book")

    if Book and Book:FindFirstChild("ClickDetector") then
        local OldPos = RootPart.CFrame

        for i = 1, 12 do
            RootPart.CFrame = Book.CFrame
            fireclickdetector(Book:FindFirstChild("ClickDetector"))
            task.wait(0)
        end

        RootPart.CFrame = OldPos
    else
        warn("Erro ao encontrar o Book! Tente novamente.")
    end
end

for i = 1, 9999999999999999 do
    duplicarBook()
    task.wait(0.001)
end
  end
})

local Section = TabTroll:AddSection({"Wall Tools"})

local BNumber = 600 -- Valor fixo
local distanciaEntreItens = 3 -- Dist√¢ncia entre os itens ao longo do bast√£o

-- Fun√ß√£o para organizar itens em forma de bast√£o gigante para baixo
local function organizarItensEmBastaoParaBaixo()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player.Backpack
    local rootPart = character:WaitForChild("HumanoidRootPart")

    -- Coleta todos os Tools no personagem e na mochila
    local itens = {}

    -- Procura Tools no personagem
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") and item.Name == "FireX" then
            table.insert(itens, item)
        end
    end

    -- Procura Tools na mochila
    for _, item in pairs(backpack:GetChildren()) do
        if item:IsA("Tool") and item.Name == "FireX" then
            table.insert(itens, item)
        end
    end

    -- Verifica duplicatas e organiza por nome
    local duplicatas = {}
    for _, item in pairs(itens) do
        if not duplicatas[item.Name] then
            duplicatas[item.Name] = {}
        end
        table.insert(duplicatas[item.Name], item)
    end

    -- Para cada grupo de duplicatas, organize-os em formato de bast√£o
    local yOffset = 0 -- Offset inicial no eixo Y
    for _, grupo in pairs(duplicatas) do
        local total = #grupo
        if total > 1 then
            for i, item in pairs(grupo) do
                -- Equipa o item para ajustar o GripPos
                item.Parent = character

                -- Define a posi√ß√£o vertical para o item no bast√£o (para baixo no eixo Y)
                item.GripPos = Vector3.new(0, -yOffset, 0)

                -- Incrementa o offset no eixo Y para "descer"
                yOffset = yOffset + distanciaEntreItens

                -- Aguarda um pouco para o efeito ser vis√≠vel
                task.wait()

                -- Solta o item colocando de volta na mochila
                item.Parent = backpack
            end
        end
    end

    -- Equipa todos os itens "FireX" da mochila
    for _, item in pairs(backpack:GetChildren()) do
        if item:IsA("Tool") and item.Name == "FireX" then
            item.Parent = character
        end
    end
end


TabTroll:AddButton({
  Name = "Firex Bast√£o Gigante para Baixo",
  Callback = function()
    local Player = game.Players.LocalPlayer
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local RootPart = Character:WaitForChild("HumanoidRootPart")

        -- Atualiza√ß√£o da hierarquia para FireX
        local Clone = game:GetService("Workspace"):FindFirstChild("WorkspaceCom")
            and game:GetService("Workspace").WorkspaceCom:FindFirstChild("001_GiveTools")
            and game:GetService("Workspace").WorkspaceCom["001_GiveTools"]:FindFirstChild("FireX")

        if Clone and Clone:FindFirstChild("ClickDetector") then
            local OldPos = RootPart.CFrame -- Armazena a posi√ß√£o original

            -- Loop para pegar os itens repetidamente
            local processed = 0
            while processed < BNumber do
                RootPart.CFrame = Clone.CFrame -- Teletransporta para o clone
                fireclickdetector(Clone.ClickDetector) -- Clica no detector
                processed = processed + 1
                task.wait() -- Pausa para evitar travamento
            end

            -- Retorna √† posi√ß√£o original
            RootPart.CFrame = OldPos

            -- Executa a fun√ß√£o de organiza√ß√£o ao final do loop
            organizarItensEmBastaoParaBaixo()
        else
            warn("FireX ou ClickDetector n√£o encontrado!")
        end
  end
})


local BNumber = 600 -- Valor fixo
local raioCirculo = 5 -- Dist√¢ncia do c√≠rculo em rela√ß√£o ao personagem

-- Fun√ß√£o para organizar itens em formato de c√≠rculo
local function organizarItensEmCirculo()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local backpack = player.Backpack
local rootPart = character:WaitForChild("HumanoidRootPart")

-- Coleta todos os Tools no personagem e na mochila  
local itens = {}  
  
-- Procura Tools no personagem  
for _, item in pairs(character:GetChildren()) do  
    if item:IsA("Tool") and item.Name == "FireX" then  
        table.insert(itens, item)  
    end  
end  
  
-- Procura Tools na mochila  
for _, item in pairs(backpack:GetChildren()) do  
    if item:IsA("Tool") and item.Name == "FireX" then  
        table.insert(itens, item)  
    end  
end  
  
-- Verifica duplicatas e organiza por nome  
local duplicatas = {}  
for _, item in pairs(itens) do  
    if not duplicatas[item.Name] then  
        duplicatas[item.Name] = {}  
    end  
    table.insert(duplicatas[item.Name], item)  
end  
  
-- Para cada grupo de duplicatas, organize-os em formato de c√≠rculo  
for _, grupo in pairs(duplicatas) do  
    local total = #grupo  
    if total > 1 then  
        for i, item in pairs(grupo) do  
            -- Equipa o item para ajustar o GripPos  
            item.Parent = character  
              
            -- Calcula o √¢ngulo de cada item no c√≠rculo  
            local angulo = (i / total) * (2 * math.pi)  
              
            -- Calcula a posi√ß√£o circular atr√°s do jogador  
            local offsetX = math.cos(angulo) * raioCirculo  
            local offsetZ = math.sin(angulo) * raioCirculo  
              
            -- Define a posi√ß√£o atr√°s do HumanoidRootPart  
            item.GripPos = Vector3.new(-offsetX, 0, -offsetZ - raioCirculo)  
              
            -- Aguarda um pouco para o efeito ser vis√≠vel  
            task.wait()  
              
            -- Solta o item colocando de volta na mochila  
            item.Parent = backpack  
        end  
    end  
end  
  
-- Equipa todos os itens "FireX" da mochila  
for _, item in pairs(backpack:GetChildren()) do  
    if item:IsA("Tool") and item.Name == "FireX" then  
        item.Parent = character  
    end  
end

end


TabTroll:AddButton({
  Name = "Firex Ex S√≠mbolo Circular",
  Callback = function()
    local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local RootPart = Character:WaitForChild("HumanoidRootPart")

-- Atualiza√ß√£o da hierarquia para FireX  
    local Clone = game:GetService("Workspace"):FindFirstChild("WorkspaceCom")   
        and game:GetService("Workspace").WorkspaceCom:FindFirstChild("001_GiveTools")  
        and game:GetService("Workspace").WorkspaceCom["001_GiveTools"]:FindFirstChild("FireX")  

    if Clone and Clone:FindFirstChild("ClickDetector") then  
        local OldPos = RootPart.CFrame -- Armazena a posi√ß√£o original  

        -- Loop para pegar os itens repetidamente  
        local processed = 0  
        while processed < BNumber do  
            RootPart.CFrame = Clone.CFrame -- Teletransporta para o clone  
            fireclickdetector(Clone.ClickDetector) -- Clica no detector  
            processed = processed + 1  
            task.wait() -- Pausa para evitar travamento  
        end  

        -- Retorna √† posi√ß√£o original  
        RootPart.CFrame = OldPos   

        -- Executa a fun√ß√£o de organiza√ß√£o ao final do loop  
        organizarItensEmCirculo()  
    else  
        warn("FireX ou ClickDetector n√£o encontrado!")  
    end  
  end
})


local BNumber = 600 -- Valor fixo
local distanciaAtras = 5 -- Dist√¢ncia da parede em rela√ß√£o ao personagem
local espacamentoX = 3 -- Espa√ßamento horizontal entre itens
local espacamentoY = 3 -- Espa√ßamento vertical entre itens

-- Fun√ß√£o para organizar itens em formato de parede
local function organizarItensEmParede()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local backpack = player.Backpack
    local rootPart = character:WaitForChild("HumanoidRootPart")

    -- Coleta todos os Tools no personagem e na mochila
    local itens = {}
    
    -- Procura Tools no personagem
    for _, item in pairs(character:GetChildren()) do
        if item:IsA("Tool") and item.Name == "FireX" then
            table.insert(itens, item)
        end
    end
    
    -- Procura Tools na mochila
    for _, item in pairs(backpack:GetChildren()) do
        if item:IsA("Tool") and item.Name == "FireX" then
            table.insert(itens, item)
        end
    end
    
    -- Verifica duplicatas e organiza por nome
    local duplicatas = {}
    for _, item in pairs(itens) do
        if not duplicatas[item.Name] then
            duplicatas[item.Name] = {}
        end
        table.insert(duplicatas[item.Name], item)
    end
    
    -- Organiza os itens em formato de parede
    for _, grupo in pairs(duplicatas) do
        local total = #grupo
        
        -- Calcula o n√∫mero de colunas e linhas necess√°rias
        local colunas = math.ceil(math.sqrt(total))
        local linhas = math.ceil(total / colunas)
        
        for i, item in pairs(grupo) do
            -- Calcula a posi√ß√£o na grade
            local linha = math.floor((i-1) / colunas)
            local coluna = (i-1) % colunas
            
            -- Equipa o item para ajustar o GripPos
            item.Parent = character
            
            -- Ajusta a posi√ß√£o na parede atr√°s do jogador
            item.GripPos = Vector3.new(coluna * espacamentoX, -linha * espacamentoY, -distanciaAtras)
            
            -- Aguarda um pouco para o efeito ser vis√≠vel
            task.wait()
            
            -- Solta o item colocando de volta na mochila
            item.Parent = backpack
        end
    end
    
    -- Equipa todos os itens "FireX" da mochila
    for _, item in pairs(backpack:GetChildren()) do
        if item:IsA("Tool") and item.Name == "FireX" then
            item.Parent = character
        end
    end
end


local Button = TabTroll:AddButton({
  Name = "Firex Wall",
  Callback = function()
    local Player = game.Players.LocalPlayer 
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local RootPart = Character:WaitForChild("HumanoidRootPart")
        
        -- Atualiza√ß√£o da hierarquia para FireX
        local Clone = game:GetService("Workspace"):FindFirstChild("WorkspaceCom") 
            and game:GetService("Workspace").WorkspaceCom:FindFirstChild("001_GiveTools")
            and game:GetService("Workspace").WorkspaceCom["001_GiveTools"]:FindFirstChild("FireX")

        if Clone and Clone:FindFirstChild("ClickDetector") then
            local OldPos = RootPart.CFrame -- Armazena a posi√ß√£o original

            -- Loop para pegar os itens repetidamente
            local processed = 0
            while processed < BNumber do
                RootPart.CFrame = Clone.CFrame -- Teletransporta para o clone
                fireclickdetector(Clone.ClickDetector) -- Clica no detector
                processed = processed + 1
                task.wait() -- Pausa para evitar travamento
            end

            -- Retorna √† posi√ß√£o original
            RootPart.CFrame = OldPos 

            -- Executa a fun√ß√£o de organiza√ß√£o ao final do loop
            organizarItensEmParede()
        else
            warn("FireX ou ClickDetector n√£o encontrado!")
        end
  end
})

local Toggle = TabTroll:AddToggle({
  Name = "Black Role",
  Default = false,
  Callback = function(Value)
    if Value then
            -- Quando a toggle estiver ativada
            loadstring(game:HttpGet("https://github.com/TemplariosScripts1/Tornado/raw/refs/heads/main/TornadoObfuscate.txt"))()
        else
            -- Quando a toggle estiver desativada
            loadstring(game:HttpGet("https://github.com/TemplariosScripts1/Blackhole2/raw/refs/heads/main/Blackhole2Obfuscate.txt"))()
        end
  end
})

local Section = TabTroll:AddSection({"Shutdown Server[Beta]"})

TabTroll:AddButton({
  Name = "Shutdown Serve Fire X Click Me!",
  Callback = function()
    tools = "FireX"
		lagserver = true
		if game:GetService("Workspace"):FindFirstChild("Camera") then
			game:GetService("Workspace"):FindFirstChild("Camera"):Destroy() end
			wait(0.1)
		if game:GetService("Workspace"):FindFirstChild("Camera") then
		game:GetService("Workspace"):FindFirstChild("Camera"):Destroy() end
		game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Workspace").WorkspaceCom["001_GiveTools"].FireX.CFrame + Vector3.new(0,-15,0)
task.wait(0.2)
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
ddos = true
		for i=1, 425 do task.wait()
			if ddos == false then
				local args = {
					[1] = "ClearAllTools"
				}
				
				cleartoolremote:FireServer(unpack(args))
				 game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
				 game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(9999,-475,9999)
				 return
			end
			if game:GetService("Workspace"):FindFirstChild("Camera") then
				game:GetService("Workspace"):FindFirstChild("Camera"):Destroy() end
				if game:GetService("Players").LocalPlayer.Character:FindFirstChild(tools) then
					game:GetService("Players").LocalPlayer.Character:FindFirstChild(tools):Destroy() end
					if ddos == false then return end
			fireclickdetector(game:GetService("Workspace").WorkspaceCom["001_GiveTools"].FireX.ClickDetector,0)
			end
			game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
			game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-475,0)
			wait()
			lagserver = false
  end
})


TabTroll:AddButton({
  Name = "Shutdown Serve V2",
  Callback = function()
    tools = "Iphone"
		lagserver = true
		if game:GetService("Workspace"):FindFirstChild("Camera") then
			game:GetService("Workspace"):FindFirstChild("Camera"):Destroy() end
			wait(0.1)
		if game:GetService("Workspace"):FindFirstChild("Camera") then
		game:GetService("Workspace"):FindFirstChild("Camera"):Destroy() end
		game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = game:GetService("Workspace").WorkspaceCom["001_GiveTools"].FireX.CFrame + Vector3.new(0,-15,0)
task.wait(0.2)
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
ddos = true
		for i=1, 425 do task.wait()
			if ddos == false then
				local args = {
					[1] = "ClearAllTools"
				}
				
				cleartoolremote:FireServer(unpack(args))
				 game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
				 game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(9999,-475,9999)
				 return
			end
			if game:GetService("Workspace"):FindFirstChild("Camera") then
				game:GetService("Workspace"):FindFirstChild("Camera"):Destroy() end
				if game:GetService("Players").LocalPlayer.Character:FindFirstChild(tools) then
					game:GetService("Players").LocalPlayer.Character:FindFirstChild(tools):Destroy() end
					if ddos == false then return end
			fireclickdetector(game:GetService("Workspace").WorkspaceCom["001_GiveTools"].FireX.ClickDetector,0)
			end
			game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
			game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-475,0)
			wait()
			lagserver = false
  end
})


TabTroll:AddButton({
  Name = "Stop Shutdown Serve",
  Callback = function()
    ddos = false
		lagserver = false
		shutdownserver = false
  end
})


local Section = TabTroll:AddSection({"Paint Roller Art"})


local cleartoolremote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Clea1rTool1s")
local picktoolremote = game:GetService("ReplicatedStorage").RE:FindFirstChild("1Too1l")

local function safeskripz()
    if duping then
        print("Dupe Function ")
        return true
    end

    if toolgrip == true then
        print("Tool Grip ")
        return true
    end

    return false
end

-- Vari√°vel global para controlar a interrup√ß√£o do processo
local stopProcess = false

-- Fun√ß√£o para resetar o personagem
local function resetCharacter()
    local player = game.Players.LocalPlayer
    if player.Character then
        player.Character:BreakJoints()  -- Reseta o personagem
    end
end

-- Fun√ß√£o principal para criar paredes, ch√£os, linhas ou cubos
local function createToolWallOrFloor(toolName, width, height, spacingX, spacingY, isFloor, isLine, isCube)
    safeskripz()

    -- Reinicia a vari√°vel de controle ao iniciar o processo
    stopProcess = false

    local nametools = toolName .. (isFloor and " floor lel" or (isLine and " line lel" or (isCube and " cube lel" or " wall lel")))
    local oldcframe = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

    -- Verifica se o personagem est√° sentado e o levanta
    if game.Players.LocalPlayer.Character.Humanoid.Sit == true then
        task.wait()
        game.Players.LocalPlayer.Character.Humanoid.Sit = false
    end

    wait(0.1)
    local args = { [1] = "ClearAllTools" }
    cleartoolremote:FireServer(unpack(args))

    -- Remove a c√¢mera se existir
    if game:GetService("Workspace"):FindFirstChild("Camera") then
        game:GetService("Workspace"):FindFirstChild("Camera"):Destroy()
    end

    -- Teleporta o personagem para uma posi√ß√£o segura
    for m = 1, 2 do
        task.wait()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(999999999.414, -490, 999999999.414, 0.974360406, -0.175734088, 0.14049761, -0.133441404, 0.0514053069, 0.989722729, -0.181150302, -0.983094692, 0.0266370922)
    end

    task.wait(0.2)
    game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
    wait(0.3)

    local duping = true
    local iterations = isLine and width or (isCube and width * height * width or width * height)

    -- Loop de duplica√ß√£o das ferramentas
    for m = 1, iterations do
        -- Verifica se o processo foi interrompido
        if stopProcess then
            game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
            resetCharacter() -- Reseta o personagem
            return
        end

        -- Remove a c√¢mera se existir
        if game:GetService("Workspace"):FindFirstChild("Camera") then
            game:GetService("Workspace"):FindFirstChild("Camera"):Destroy()
        end

        -- Pega a ferramenta
        local args = { [1] = "PickingTools", [2] = toolName }
        picktoolremote:InvokeServer(unpack(args))
        game:GetService("Players").LocalPlayer.Backpack:WaitForChild(toolName).Parent = game.Players.LocalPlayer.Character

        -- Verifica novamente se o processo foi interrompido
        if stopProcess then
            game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
            resetCharacter() -- Reseta o personagem
            return
        end

        wait()
        game:GetService("Players").LocalPlayer.Character[toolName]:FindFirstChild("Handle").Name = "Handle"
        game:GetService("Players").LocalPlayer.Character:FindFirstChild(toolName).Parent = game.Players.LocalPlayer.Backpack
        game:GetService("Players").LocalPlayer.Backpack:FindFirstChild(toolName).Parent = game.Players.LocalPlayer.Character

        -- Espera at√© que a ferramenta seja removida do personagem
        repeat
            if game:GetService("Workspace"):FindFirstChild("Camera") then
                game:GetService("Workspace"):FindFirstChild("Camera"):Destroy()
            end
            wait()
        until game:GetService("Players").LocalPlayer.Character:FindFirstChild(toolName) == nil
    end

    -- Finaliza o processo
    game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = false
    repeat wait() until game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") == nil
    repeat wait() until game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

    local toolgrip = true
    duping = false
    wait()

    -- Posicionamento das ferramentas
    local tools = game.Players.LocalPlayer.Backpack:GetChildren()
    local baseCFrame = CFrame.new(0.0538333468, -0.264812469, -0.0177594293, 0.999998629, 0, 0.00164011808, 0, 1, 0, -0.00164011808, 0, 0.999998629)

    if isLine then
        -- Cria uma linha reta de ferramentas
        for i = 0, width - 1 do
            if tools[i + 1] then
                tools[i + 1].Grip = baseCFrame + Vector3.new(i * spacingX, spacingY, 0)
                tools[i + 1].Name = nametools
            end
        end
    elseif isCube then
        -- Cria um cubo de ferramentas
        for x = 0, width - 1 do
            for y = 0, height - 1 do
                for z = 0, width - 1 do
                    local toolIndex = x * height * width + y * width + z + 1
                    if tools[toolIndex] then
                        tools[toolIndex].Grip = baseCFrame + Vector3.new(x * spacingX, -y * spacingY, z * spacingX)
                        tools[toolIndex].Name = nametools
                    end
                end
            end
        end
    else
        -- Cria uma parede ou ch√£o de ferramentas
        for x = 0, width - 1 do
            for y = 0, height - 1 do
                local toolIndex = x * height + y + 1
                if tools[toolIndex] then
                    if isFloor then
                        tools[toolIndex].Grip = baseCFrame + Vector3.new(x * spacingX, 0, y * spacingY)
                    else
                        tools[toolIndex].Grip = baseCFrame + Vector3.new(x * spacingX, -y * spacingY, 0)
                    end
                    tools[toolIndex].Name = nametools
                end
            end
        end
    end

    -- Retorna o personagem √† posi√ß√£o original
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = oldcframe
    wait(0.5)

    -- Move as ferramentas para o personagem
    for _, tool in ipairs(game:GetService("Players").LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") and tool.Name == nametools then
            tool.Parent = game:GetService("Players").LocalPlayer.Character
        end
    end
end


TabTroll:AddButton({
  Name = "Linha De Paint Rolller 1x500",
  Callback = function()
    createToolWallOrFloor("PaintRoller", 500, 1, 2, 0, false, true)
  end
})


TabTroll:AddButton({
  Name = "Linha de PaintRoller 1x10 ",
  Callback = function()
    createToolWallOrFloor("PaintRoller", 10, 1, 2, 0, false, true)
  end
})

TabTroll:AddButton({
  Name = "Mudar Anima√ß√£o da Linha de PaintRoller",
  Callback = function()
      -- Primeiro, certifique-se de que todas as ferramentas est√£o no personagem
for _, tool in ipairs(game:GetService("Players").LocalPlayer.Backpack:GetChildren()) do
    if tool:IsA("Tool") and tool.Name == "PaintRoller line lel" then
        tool.Parent = game:GetService("Players").LocalPlayer.Character
    end
end

-- Agora execute o comando em todas as ferramentas
for _, tool in ipairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
    if tool:IsA("Tool") and tool.Name == "PaintRoller line lel" then
        tool.CycleNextAnimation:FireServer()
        -- Adicione um pequeno delay se necess√°rio para evitar problemas
    end
end
  end
})


TabTroll:AddButton({
  Name = "Equipar Todas as Tools",
  Callback = function()
    local function equiptool()
  for i,v in ipairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
    if v:IsA("Tool") then
      v.Parent = game.Players.LocalPlayer.Character
    end
  end
end
equiptool()
  end
})


TabTroll:AddButton({
  Name = "Para Processo De constru√ß√£o",
  Callback = function()
    stopProcess = true
    resetCharacter()
  end
})

local Paragraph = TabTroll:AddParagraph({"Aviso", "Script black hole N e meu!!"})

local TabAnt = Window:MakeTab({ "Ant", "rbxassetid://10709790644" })

local player = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")

local renderConnection, seatedConnection, charConn

TabAnt:AddToggle({
    Name = "Anti Sit",
    Default = false,
    Callback = function(Value)
        if Value then
            enableAntiSit(player.Character or player.CharacterAdded:Wait())
            charConn = player.CharacterAdded:Connect(function(char)
                disableAntiSit()
                enableAntiSit(char)
            end)
        else
            disableAntiSit()
        end
    end
})

-- Fun√ß√£o que impede o jogador de sentar
function enableAntiSit(character)
    local humanoid = character:WaitForChild("Humanoid")
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

    seatedConnection = humanoid.Seated:Connect(function(active)
        if active then
            humanoid.Sit = false
            humanoid.SeatPart = nil
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            character:PivotTo(character:GetPivot() + Vector3.new(0, 5, 0))
        end
    end)

    renderConnection = rs.RenderStepped:Connect(function()
        if humanoid.Sit then
            humanoid.Sit = false
            humanoid.SeatPart = nil
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
            character:PivotTo(character:GetPivot() + Vector3.new(0, 5, 0))
        end
    end)
end

-- Fun√ß√£o para remover o anti sit
function disableAntiSit()
    if renderConnection then renderConnection:Disconnect() renderConnection = nil end
    if seatedConnection then seatedConnection:Disconnect() seatedConnection = nil end
    if charConn then charConn:Disconnect() charConn = nil end

    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    end
end

-- Voc√™ tamb√©m pode usar isso depois se quiser desativar por script:
-- Toggle:Set(false)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local lastSafePos = Vector3.new(-26.09, 2.79, 6.11)
local avoidConn

TabAnt:AddToggle({
    Name = "Anti Void",
    Default = false,
    Callback = function(Value)
        if avoidConn then
            avoidConn:Disconnect()
            avoidConn = nil
        end

        if Value then
            avoidConn = RunService.Stepped:Connect(function()
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                local pos = hrp.Position

                -- Atualiza a √∫ltima posi√ß√£o segura
                if pos.Y > -20 and pos.Y < 1000 and math.abs(pos.X) < 2000 and math.abs(pos.Z) < 2000 then
                    lastSafePos = pos
                end

                -- Detecta void ou posi√ß√µes extremas
                if pos.Y < -50 or pos.Y > 1500 or math.abs(pos.X) > 3000 or math.abs(pos.Z) > 3000 then
                    hrp.CFrame = CFrame.new(lastSafePos)

                    pcall(function()
                        game.StarterGui:SetCore("SendNotification", {
                            Title = "Anti Avoid",
                            Text = "Tentativa de kill bloqueada",
                            Duration = 2
                        })
                    end)
                end
            end)
        end
    end
})

-- Para desativar programaticamente depois:
-- Toggle:Set(false)

TabAnt:AddToggle({
    Name = "Anti Kick",
    Default = false,
    Callback = function(Value)
        getgenv().ED_AntiKick = getgenv().ED_AntiKick or {}
        getgenv().ED_AntiKick.Enabled = Value

        if Value then
            -- Anti Kick Ativado
            local getgenv, getnamecallmethod, hookmetamethod, hookfunction, newcclosure, checkcaller, lower, gsub = getgenv, getnamecallmethod, hookmetamethod, hookfunction, newcclosure, checkcaller, string.lower, string.gsub

            if getgenv().ED_AntiKick.__loaded then return end
            getgenv().ED_AntiKick.__loaded = true

            local cloneref = cloneref or function(...) return ... end
            local clonefunction = clonefunction or function(...) return ... end

            local Players = cloneref(game:GetService("Players"))
            local LocalPlayer = cloneref(Players.LocalPlayer)
            local StarterGui = cloneref(game:GetService("StarterGui"))
            local SetCore = clonefunction(StarterGui.SetCore)
            local FindFirstChild = clonefunction(game.FindFirstChild)

            local CompareInstances = function(a, b)
                return typeof(a) == "Instance" and typeof(b) == "Instance"
            end

            local CanCastToSTDString = function(...)
                return pcall(FindFirstChild, game, ...)
            end

            getgenv().ED_AntiKick.SendNotifications = true
            getgenv().ED_AntiKick.CheckCaller = true

            local OldNamecall; OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
                local self, msg = ...
                local method = getnamecallmethod()

                if ((getgenv().ED_AntiKick.CheckCaller and not checkcaller()) or true)
                    and CompareInstances(self, LocalPlayer)
                    and gsub(method, "^%l", string.upper) == "Kick"
                    and getgenv().ED_AntiKick.Enabled then
                    
                    if CanCastToSTDString(msg) and getgenv().ED_AntiKick.SendNotifications then
                        SetCore(StarterGui, "SendNotification", {
                            Title = "Anti Kick",
                            Text = "Tentativa de kick bloqueada.",
                            Icon = "rbxassetid://6238540373",
                            Duration = 2
                        })
                    end
                    return
                end

                return OldNamecall(...)
            end))

            local OldKick; OldKick = hookfunction(LocalPlayer.Kick, newcclosure(function(...)
                local self, msg = ...
                if ((getgenv().ED_AntiKick.CheckCaller and not checkcaller()) or true)
                    and CompareInstances(self, LocalPlayer)
                    and getgenv().ED_AntiKick.Enabled then

                    if CanCastToSTDString(msg) and getgenv().ED_AntiKick.SendNotifications then
                        SetCore(StarterGui, "SendNotification", {
                            Title = "Anti Kick",
                            Text = "Tentativa de kick bloqueada.",
                            Icon = "rbxassetid://6238540373",
                            Duration = 2
                        })
                    end
                    return
                end
            end))

            -- Notifica√ß√£o de carregamento
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = "Anexed Notificator Anti-Kick",
                    Text = "Script Anti-Kick ativado.",
                    Icon = "rbxassetid://6238537240",
                    Duration = 3
                })
            end)
        else
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = "Anxed Notificator Anti-Kick",
                    Text = "Script Anti-Kick desativado.",
                    Icon = "rbxassetid://6238537240",
                    Duration = 3
                })
            end)
        end
    end
})

local TabAvatar = Window:MakeTab({ "Avatar", "rbxassetid://10709812159" })

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

local Target = nil

-- Fun√ß√£o para obter os nomes dos jogadores
local function GetPlayerNames()
    local PlayerNames = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(PlayerNames, player.Name)
    end
    return PlayerNames
end

-- Dropdown de sele√ß√£o de jogador
TabAvatar:AddDropdown({
    Name = "Selecionar Jogador Para a C√≥pia",
    Options = GetPlayerNames(),
    Default = Target,
    Callback = function(Value)
        Target = Value
    end
})

-- Atualiza op√ß√µes do dropdown quando algu√©m entra ou sai
local function UpdateDropdown()
    Dropdown:Refresh(GetPlayerNames(), true)
end

Players.PlayerAdded:Connect(UpdateDropdown)
Players.PlayerRemoving:Connect(UpdateDropdown)

-- Bot√£o de copiar avatar
TabAvatar:AddButton({
    Name = "Copy Avatar",
    Callback = function()
        if not Target then return end

        local LP = Players.LocalPlayer
        local LChar = LP.Character
        local TPlayer = Players:FindFirstChild(Target)

        if TPlayer and TPlayer.Character then
            local LHumanoid = LChar and LChar:FindFirstChildOfClass("Humanoid")
            local THumanoid = TPlayer.Character:FindFirstChildOfClass("Humanoid")

            if LHumanoid and THumanoid then
                -- RESETAR LOCALPLAYER
                local LDesc = LHumanoid:GetAppliedDescription()

                -- Remover acess√≥rios, roupas e face atuais
                for _, acc in ipairs(LDesc:GetAccessories(true)) do
                    if acc.AssetId and tonumber(acc.AssetId) then
                        Remotes.Wear:InvokeServer(tonumber(acc.AssetId))
                        task.wait(0.2)
                    end
                end

                if tonumber(LDesc.Shirt) then
                    Remotes.Wear:InvokeServer(tonumber(LDesc.Shirt))
                    task.wait(0.2)
                end

                if tonumber(LDesc.Pants) then
                    Remotes.Wear:InvokeServer(tonumber(LDesc.Pants))
                    task.wait(0.2)
                end

                if tonumber(LDesc.Face) then
                    Remotes.Wear:InvokeServer(tonumber(LDesc.Face))
                    task.wait(0.2)
                end

                -- COPIAR DO JOGADOR ALVO
                local PDesc = THumanoid:GetAppliedDescription()

                -- Enviar partes do corpo
                local argsBody = {
                    [1] = {
                        [1] = PDesc.Torso,
                        [2] = PDesc.RightArm,
                        [3] = PDesc.LeftArm,
                        [4] = PDesc.RightLeg,
                        [5] = PDesc.LeftLeg,
                        [6] = PDesc.Head
                    }
                }
                Remotes.ChangeCharacterBody:InvokeServer(unpack(argsBody))
                task.wait(0.5)

                if tonumber(PDesc.Shirt) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.Shirt))
                    task.wait(0.3)
                end

                if tonumber(PDesc.Pants) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.Pants))
                    task.wait(0.3)
                end

                if tonumber(PDesc.Face) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.Face))
                    task.wait(0.3)
                end

                for _, v in ipairs(PDesc:GetAccessories(true)) do
                    if v.AssetId and tonumber(v.AssetId) then
                        Remotes.Wear:InvokeServer(tonumber(v.AssetId))
                        task.wait(0.3)
                    end
                end

                local SkinColor = TPlayer.Character:FindFirstChild("Body Colors")
                if SkinColor then
                    Remotes.ChangeBodyColor:FireServer(tostring(SkinColor.HeadColor))
                    task.wait(0.3)
                end

                if tonumber(PDesc.IdleAnimation) then
                    Remotes.Wear:InvokeServer(tonumber(PDesc.IdleAnimation))
                    task.wait(0.3)
                end

                -- Nome, bio e cor
                local Bag = TPlayer:FindFirstChild("PlayersBag")
                if Bag then
                    if Bag:FindFirstChild("RPName") and Bag.RPName.Value ~= "" then
                        Remotes.RPNameText:FireServer("RolePlayName", Bag.RPName.Value)
                        task.wait(0.3)
                    end
                    if Bag:FindFirstChild("RPBio") and Bag.RPBio.Value ~= "" then
                        Remotes.RPNameText:FireServer("RolePlayBio", Bag.RPBio.Value)
                        task.wait(0.3)
                    end
                    if Bag:FindFirstChild("RPNameColor") then
                        Remotes.RPNameColor:FireServer("PickingRPNameColor", Bag.RPNameColor.Value)
                        task.wait(0.3)
                    end
                    if Bag:FindFirstChild("RPBioColor") then
                        Remotes.RPNameColor:FireServer("PickingRPBioColor", Bag.RPBioColor.Value)
                        task.wait(0.3)
                    end
                end
            end
        end
    end
})

TabAvatar:AddButton({
    Name = "Copy Nearest Avatar",
    Callback = function()
        local LP = Players.LocalPlayer
        local LChar = LP.Character
        if not LChar or not LChar:FindFirstChild("HumanoidRootPart") then return end

        -- Localizar o jogador mais pr√≥ximo
        local closestPlayer, closestDistance = nil, math.huge
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LP and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (LChar.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestPlayer = plr
                end
            end
        end

        -- Usar o jogador mais pr√≥ximo como Target
        if not closestPlayer then return end
        local TPlayer = closestPlayer

        -- (c√≥digo de c√≥pia do avatar igual ao seu original, substituindo "Target" por TPlayer.Name)
        -- [REUTILIZA A MESMA L√ìGICA, S√ì TROCA A PARTE DO TARGET]
        local LHumanoid = LChar and LChar:FindFirstChildOfClass("Humanoid")
        local THumanoid = TPlayer.Character:FindFirstChildOfClass("Humanoid")

        if LHumanoid and THumanoid then
            local LDesc = LHumanoid:GetAppliedDescription()

            for _, acc in ipairs(LDesc:GetAccessories(true)) do
                if acc.AssetId and tonumber(acc.AssetId) then
                    Remotes.Wear:InvokeServer(tonumber(acc.AssetId))
                    task.wait(0.2)
                end
            end

            if tonumber(LDesc.Shirt) then
                Remotes.Wear:InvokeServer(tonumber(LDesc.Shirt))
                task.wait(0.2)
            end

            if tonumber(LDesc.Pants) then
                Remotes.Wear:InvokeServer(tonumber(LDesc.Pants))
                task.wait(0.2)
            end

            if tonumber(LDesc.Face) then
                Remotes.Wear:InvokeServer(tonumber(LDesc.Face))
                task.wait(0.2)
            end

            local PDesc = THumanoid:GetAppliedDescription()

            local argsBody = {
                [1] = {
                    [1] = PDesc.Torso,
                    [2] = PDesc.RightArm,
                    [3] = PDesc.LeftArm,
                    [4] = PDesc.RightLeg,
                    [5] = PDesc.LeftLeg,
                    [6] = PDesc.Head
                }
            }
            Remotes.ChangeCharacterBody:InvokeServer(unpack(argsBody))
            task.wait(0.5)

            if tonumber(PDesc.Shirt) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.Shirt))
                task.wait(0.3)
            end

            if tonumber(PDesc.Pants) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.Pants))
                task.wait(0.3)
            end

            if tonumber(PDesc.Face) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.Face))
                task.wait(0.3)
            end

            for _, v in ipairs(PDesc:GetAccessories(true)) do
                if v.AssetId and tonumber(v.AssetId) then
                    Remotes.Wear:InvokeServer(tonumber(v.AssetId))
                    task.wait(0.3)
                end
            end

            local SkinColor = TPlayer.Character:FindFirstChild("Body Colors")
            if SkinColor then
                Remotes.ChangeBodyColor:FireServer(tostring(SkinColor.HeadColor))
                task.wait(0.3)
            end

            if tonumber(PDesc.IdleAnimation) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.IdleAnimation))
                task.wait(0.3)
            end

            local Bag = TPlayer:FindFirstChild("PlayersBag")
            if Bag then
                if Bag:FindFirstChild("RPName") and Bag.RPName.Value ~= "" then
                    Remotes.RPNameText:FireServer("RolePlayName", Bag.RPName.Value)
                    task.wait(0.3)
                end
                if Bag:FindFirstChild("RPBio") and Bag.RPBio.Value ~= "" then
                    Remotes.RPNameText:FireServer("RolePlayBio", Bag.RPBio.Value)
                    task.wait(0.3)
                end
                if Bag:FindFirstChild("RPNameColor") then
                    Remotes.RPNameColor:FireServer("PickingRPNameColor", Bag.RPNameColor.Value)
                    task.wait(0.3)
                end
                if Bag:FindFirstChild("RPBioColor") then
                    Remotes.RPNameColor:FireServer("PickingRPBioColor", Bag.RPBioColor.Value)
                    task.wait(0.3)
                end
            end
        end
    end
})

TabAvatar:AddButton({
    Name = "Copy Random Avatar",
    Callback = function()
        local LP = Players.LocalPlayer
        local LChar = LP.Character
        if not LChar then return end

        -- Escolher um player aleat√≥rio (exceto o pr√≥prio)
        local otherPlayers = {}
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LP and plr.Character then
                table.insert(otherPlayers, plr)
            end
        end
        if #otherPlayers == 0 then return end

        local TPlayer = otherPlayers[math.random(1, #otherPlayers)]

        -- Mesmo c√≥digo de c√≥pia
        local LHumanoid = LChar:FindFirstChildOfClass("Humanoid")
        local THumanoid = TPlayer.Character:FindFirstChildOfClass("Humanoid")
        if LHumanoid and THumanoid then
            local LDesc = LHumanoid:GetAppliedDescription()
            for _, acc in ipairs(LDesc:GetAccessories(true)) do
                if acc.AssetId and tonumber(acc.AssetId) then
                    Remotes.Wear:InvokeServer(tonumber(acc.AssetId))
                    task.wait(0.2)
                end
            end
            if tonumber(LDesc.Shirt) then
                Remotes.Wear:InvokeServer(tonumber(LDesc.Shirt))
                task.wait(0.2)
            end
            if tonumber(LDesc.Pants) then
                Remotes.Wear:InvokeServer(tonumber(LDesc.Pants))
                task.wait(0.2)
            end
            if tonumber(LDesc.Face) then
                Remotes.Wear:InvokeServer(tonumber(LDesc.Face))
                task.wait(0.2)
            end

            local PDesc = THumanoid:GetAppliedDescription()
            local argsBody = {
                [1] = {
                    [1] = PDesc.Torso,
                    [2] = PDesc.RightArm,
                    [3] = PDesc.LeftArm,
                    [4] = PDesc.RightLeg,
                    [5] = PDesc.LeftLeg,
                    [6] = PDesc.Head
                }
            }
            Remotes.ChangeCharacterBody:InvokeServer(unpack(argsBody))
            task.wait(0.5)

            if tonumber(PDesc.Shirt) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.Shirt))
                task.wait(0.3)
            end
            if tonumber(PDesc.Pants) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.Pants))
                task.wait(0.3)
            end
            if tonumber(PDesc.Face) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.Face))
                task.wait(0.3)
            end
            for _, v in ipairs(PDesc:GetAccessories(true)) do
                if v.AssetId and tonumber(v.AssetId) then
                    Remotes.Wear:InvokeServer(tonumber(v.AssetId))
                    task.wait(0.3)
                end
            end

            local SkinColor = TPlayer.Character:FindFirstChild("Body Colors")
            if SkinColor then
                Remotes.ChangeBodyColor:FireServer(tostring(SkinColor.HeadColor))
                task.wait(0.3)
            end
            if tonumber(PDesc.IdleAnimation) then
                Remotes.Wear:InvokeServer(tonumber(PDesc.IdleAnimation))
                task.wait(0.3)
            end

            local Bag = TPlayer:FindFirstChild("PlayersBag")
            if Bag then
                if Bag:FindFirstChild("RPName") and Bag.RPName.Value ~= "" then
                    Remotes.RPNameText:FireServer("RolePlayName", Bag.RPName.Value)
                    task.wait(0.3)
                end
                if Bag:FindFirstChild("RPBio") and Bag.RPBio.Value ~= "" then
                    Remotes.RPNameText:FireServer("RolePlayBio", Bag.RPBio.Value)
                    task.wait(0.3)
                end
                if Bag:FindFirstChild("RPNameColor") then
                    Remotes.RPNameColor:FireServer("PickingRPNameColor", Bag.RPNameColor.Value)
                    task.wait(0.3)
                end
                if Bag:FindFirstChild("RPBioColor") then
                    Remotes.RPNameColor:FireServer("PickingRPBioColor", Bag.RPBioColor.Value)
                    task.wait(0.3)
                end
            end
        end
    end
})

local TabScripts = Window:MakeTab({ "Scripts", "rbxassetid://10709782497" })

TabScripts:AddButton({
    Name = "tp tool",
    Callback = function()
        -- tp

mouse = game.Players.LocalPlayer:GetMouse()
tool = Instance.new("Tool")
tool.RequiresHandle = false
tool.Name = "Equip to Click TP"
tool.Activated:connect(function()
local pos = mouse.Hit+Vector3.new(0,2.5,0)
pos = CFrame.new(pos.X,pos.Y,pos.Z)
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = pos
end)
tool.Parent = game.Players.LocalPlayer.Backpack
    end
})

TabScripts:AddButton({
    Name = "Kill tool",
    Callback = function()
        -- Cria√ß√£o da ferramenta
local tool = Instance.new("Tool")
tool.RequiresHandle = false
tool.Name = "kill tool"

tool.Activated:connect(function()
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()
    local target = mouse.Target

    -- Verifica se o mouse atingiu um personagem
    if target and target.Parent and target.Parent:FindFirstChild("Humanoid") then
        local targetPlayer = game.Players:GetPlayerFromCharacter(target.Parent)

        -- Se encontrou um jogador, processa o teleport
        if targetPlayer then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")

            -- Se o humanoide e a ra√≠z do personagem alvo forem encontrados
            if humanoidRootPart and targetRootPart then
                -- Teleporta o jogador para a posi√ß√£o do alvo (adicionando um offset de altura)
                humanoidRootPart.CFrame = targetRootPart.CFrame + Vector3.new(0, 5, 0)

                -- Movimenta o carro do jogador
                local Vehicles = game.Workspace:FindFirstChild("Vehicles")
                local oldPos = humanoidRootPart.CFrame

                -- Spawn do carro, caso n√£o exista
                local PCar = Vehicles:FindFirstChild(player.Name.."Car")
                if not PCar then
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = CFrame.new(1118.81, 75.998, -1138.61)  -- Posi√ß√£o inicial
                        task.wait(0.5)
                        game:GetService("ReplicatedStorage").RE:FindFirstChild("1Ca1r"):FireServer("PickingCar", "SchoolBus")
                        task.wait(0.5)
                        PCar = Vehicles:FindFirstChild(player.Name.."Car")
                        task.wait(0.5)

                        local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                        if Seat then
                            repeat
                                task.wait()
                                humanoidRootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                            until player.Character.Humanoid.Sit
                        end
                    end
                end

                -- Verifica novamente ap√≥s um tempo
                task.wait(0.5)
                PCar = Vehicles:FindFirstChild(player.Name.."Car")
                if PCar and not player.Character.Humanoid.Sit then
                    local Seat = PCar:FindFirstChild("Body") and PCar.Body:FindFirstChild("VehicleSeat")
                    if Seat then
                        repeat
                            task.wait()
                            humanoidRootPart.CFrame = Seat.CFrame * CFrame.new(0, math.random(-1, 1), 0)
                        until player.Character.Humanoid.Sit
                    end
                end

                -- Aguarda o jogador se sentar e come√ßa o movimento do carro ao redor do alvo
                local targetCharacter = targetPlayer.Character
                local targetHumanoid = targetCharacter and targetCharacter:FindFirstChildOfClass("Humanoid")
                local targetRP = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")

                if targetCharacter and targetHumanoid and targetRP then
                    if not targetHumanoid.Sit then
                        while not targetHumanoid.Sit do
                            task.wait()

                            -- Gera rota√ß√µes aleat√≥rias
                            local randomX = math.random(-360, 360)
                            local randomY = math.random(-360, 360)
                            local randomZ = math.random(-360, 360)

                            -- Fun√ß√£o para movimentar o carro ao redor do alvo
                            local moveCar = function(targetRP, pos, angle)
                                PCar:SetPrimaryPartCFrame(CFrame.new(targetRP.Position) * pos * angle)
                            end

                            -- Movimentos aleat√≥rios do carro ao redor do alvo
                            moveCar(targetRP, CFrame.new(0, 1, 0) + targetHumanoid.MoveDirection * targetRP.Velocity.Magnitude / 1.05, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                            moveCar(targetRP, CFrame.new(0, -2.25, 5) + targetHumanoid.MoveDirection * targetRP.Velocity.Magnitude / 1.05, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                            moveCar(targetRP, CFrame.new(0, 2.25, 0.25) + targetHumanoid.MoveDirection * targetRP.Velocity.Magnitude / 1.10, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                            moveCar(targetRP, CFrame.new(-2.25, -1.5, 2.25) + targetHumanoid.MoveDirection * targetRP.Velocity.Magnitude / 1.10, CFrame.Angles(math.rad(randomX), math.rad(randomY), math.rad(randomZ)))
                        end

                        -- Quando o alvo sentar, mover o carro para longe e retornar √† posi√ß√£o original
                        task.wait(0.1)
                        PCar:SetPrimaryPartCFrame(CFrame.new(0, -470, 0))  -- Mover o carro para longe
                        task.wait(0.2)

                        -- Finaliza o processo
                        player.Character.Humanoid.Sit = false
                        task.wait(0.1)
                        humanoidRootPart.CFrame = oldPos  -- Retorna √† posi√ß√£o original
                    end
                end
            end
        end
    end
end)

-- Adiciona a ferramenta ao invent√°rio do jogador
tool.Parent = game.Players.LocalPlayer.Backpack
    end
})

TabScripts:AddButton({
    Name = "Delete All Items",
    Callback = function()
        -- Deletando todos os itens do invent√°rio
        local player = game.Players.LocalPlayer
        for _, item in pairs(player.Backpack:GetChildren()) do
            if item:IsA("Tool") then
                item:Destroy()  -- Deleta o item
            end
        end
    end
})

TabScripts:AddSection({ "Variavels de Script-" })

TabScripts:AddButton({
    Name = "infinity‚Ä¢Yield",
    Callback = function()
 loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Infinity-Yield-Loader-Script-30985"))()
    end
})

TabScripts:AddButton({
    Name = "shift‚Ä¢lock-MB",
    Callback = function()
 loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Shiftlock-For-Mobile-Script-36530"))()
    end
})

local Paragraph = TabScripts:AddParagraph({"Aviso", "Todos os scripts n S√£o Meu "})

local TabChat = Window:MakeTab({"Chat", "10723415903"})

-- Se√ß√£o: Enviar uma mensagem normal
local playerInput1 = ""

TabChat:AddSection({Name = "Enviar uma Mensagem no Chat"})

TabChat:AddTextBox({
    Name = "Mensagem Chat",
    Default = "",
    TextDisappear = false,
    Callback = function(text)
        playerInput1 = text
    end
})

TabChat:AddButton({
    Name = "Enviar",
    Callback = function()
        local TextChatService = game:GetService("TextChatService")
        if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
            local message = ".\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r" .. playerInput1
            TextChatService.TextChannels.RBXGeneral:SendAsync(message)
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Not Supported",
                Text = "Este jogo usa o chat antigo do Roblox. Esse recurso s√≥ funciona no chat novo."
            })
        end
    end
})

-- Se√ß√£o: Enviar mensagem com prefixo System
local playerInput2 = ""

TabChat:AddSection({Name = "Enviar Uma Mensagem usando System"})

TabChat:AddTextBox({
    Name = "mensagem System",
    Default = "",
    TextDisappear = false,
    Callback = function(text)
        playerInput2 = text
    end
})

TabChat:AddButton({
    Name = "Enviar ",
    Callback = function()
        local TextChatService = game:GetService("TextChatService")
        if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
            local message = ".\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\rSystem: " .. playerInput2
            TextChatService.TextChannels.RBXGeneral:SendAsync(message)
        else
            game:GetService("StarterGui"):SetCore("SendNotification", {
                Title = "Not Supported",
                Text = "Este jogo usa o chat antigo do Roblox. Esse recurso s√≥ funciona no chat novo."
            })
        end
    end
})